/* Entry point for all derivations                                           */
/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

pred derivation i:inductive, i:string, o:derive.
pred export i:modpath.
pred dep1 o:string, o:string.
kind derive type.
type derive string -> (A -> prop) -> derive.

dep1 "lens_laws" "lens".
dep1 "eqOK" "eqcorrect".
dep1 "eqOK" "param1_trivial".
dep1 "param1_trivial" "param1_inhab".
dep1 "param1_trivial" "param1_congr".
dep1 "param1_congr" "param1".
dep1 "param1_trivial" "param1".
dep1 "param1_functor" "param1".
dep1 "eqcorrect" "induction".
dep1 "eqcorrect" "eq".
dep1 "eqcorrect" "eqK".
dep1 "induction" "param1_functor".
dep1 "induction" "param1_functor".
dep1 "eqK" "bcongr".
dep1 "eqK" "isK".
dep1 "bcongr" "projK".
dep1 "idx2inv" "invert".
dep1 "eq_param1" "eq".
derivation T Prefix (derive "isK"            (derive.isK.main T                      N     )) :- N is Prefix ^ "isk_".
derivation T Prefix (derive "projK"          (derive.projK.main T                    N     )) :- N is Prefix ^ "getk_".
derivation T Prefix (derive "param1"         (derive.param1.main (indt T)            N     )) :- N is Prefix ^ "is_".
derivation T _      (derive "param1_congr"   (derive.on_param1 T derive.param1.congr.main   "congr_")).
derivation T _      (derive "param1_inhab"   (derive.on_param1 T derive.param1.inhab.main   "_full")).
derivation T _      (derive "param1_trivial" (derive.on_param1 T derive.param1.trivial.main "_trivial")).
derivation T _      (derive "param1_functor" (derive.on_param1 T derive.param1.functor.main "_functor")).
derivation T Prefix (derive "induction"      (derive.induction.main T                N     )) :- N is Prefix ^ "induction".
derivation T Prefix (derive "eq"             (derive.eq.main T                       N     )) :- N is Prefix ^ "eq".
derivation T Prefix (derive "eq_param1"      (derive.on_eq T (x\derive.param1.main (const x)) N     )) :- N is Prefix ^ "param1_".
derivation T Prefix (derive "bcongr"         (derive.bcongr.main T                   N     )) :- N is Prefix ^ "bcongr_".
derivation T Prefix (derive "eqK"            (derive.eqK.main T                      N     )) :- N is Prefix ^ "eq_axiom_".
derivation T Prefix (derive "eqcorrect"      (derive.eqcorrect.main T                N     )) :- N is Prefix ^ "eq_correct".
derivation T Prefix (derive "eqOK"           (derive.eqOK.main T                     N     )) :- N is Prefix ^ "eq_OK".
derivation T Prefix (derive "param2"         (derive.param2.main (indt T)            N     )) :- N is Prefix ^ "_R".
derivation T Prefix (derive "invert"         (derive.invert.main T                   N     )) :- N is Prefix ^ "inv".
derivation T _      (derive "idx2inv"        (derive.idx2inv.main T                  "_to_")).
derivation T Prefix (derive "lens"           (derive.lens.main T                     N     )) :- N is Prefix ^ "_".
derivation T Prefix (derive "lens_laws"      (derive.lens-laws.main T                N     )) :- N is Prefix ^ "_".
derivation T Prefix (derive "tag"            (derive.tag.main T                      Prefix)).
namespace derive {

pred if-verbose i:prop.
if-verbose P :- get-option "verbose" tt, !, P.
if-verbose _.

pred dep o:string, o:string.
dep X Y :- dep1 X Y.
dep X Y :- dep1 X Z, dep Z Y.

pred selected i:string.
selected Name :- get-option "only" Map, !,
  Map => (get-option Name _; (get-option X _, dep X Name)).
selected _.

pred chain i:list derive, o:list prop.
chain [] [].
chain [derive Name _|FS] CL :- not(selected Name), !,
  if-verbose (coq.say "Skipping derivation" Name),
  chain FS CL.
chain [derive Name F|FS] CL :-
  if-verbose (coq.say "Derivation" Name),
  (pi x\ stop x :- !, fail) => @dropunivs! => std.time (F C) Time, !,
  if-verbose (coq.say "Derivation" Name "took" Time),
  C => chain FS CS,
  std.append C CS CL.
chain [derive F _|FS] CL :-
  if-verbose (coq.say "Derivation" F "failed"),
  chain FS CL.

pred on_param1 i:inductive, i:(inductive -> string -> list prop -> prop), i:string, o:list prop.
on_param1 T F N C :- reali (global (indt T)) (global (indt P)), !, F P N C.
pred on_eq i:inductive, i:(constant -> string -> list prop -> prop), i:string, o:list prop.
on_eq T F N X :- eq-for T C, !, F C N X.

pred toposort i:list derive, o:list derive.
toposort [] [].
toposort [X] [X].
toposort [(derive A _ as X),(derive B _ as Y)|L] [X|R] :- not (dep A B), !,
  toposort [Y|L] R1,
  if (R1 = [Y|_]) (R = R1) (toposort [X|R1] R).
toposort [X,Y|L] R :- toposort [Y,X|L] R.

pred export? i:prop, o:prop.
export? (export M) (coq.env.export-module M).

pred main i:inductive, i:string, o:list prop.
main T Prefix CL :-
  std.findall (derivation T Prefix _) L,
  std.map L (x\r\ x = derivation _ _ r) DL,
  toposort DL SortedDL,
  chain SortedDL CL.

pred decl+main i:indt-decl.
decl+main DS :- std.do! [
  indt-decl-name DS ModName,
  if-verbose (coq.say "Starting module" ModName),
  coq.env.begin-module ModName none,
  std.assert-ok! (coq.elaborate-indt-decl-skeleton DS D) "Inductive type declaration illtyped",
  if-verbose (coq.say "Declaring inductive" D),
  coq.env.add-indt D I,
  if-verbose (coq.say "Deriving"),
  main I "" CL,
  if-verbose (coq.say "Done"),
  coq.env.end-module _,

  coq.env.indt I _ _ _ _ KS _,
  std.map KS (k\r\ r = indc k) KGRS,
  std.map KGRS coq.gref->id KNS,
  std.map KGRS (gr\r\ r = global gr) KTS,

  std.forall2 [ModName|KNS] [global (indt I)|KTS] short-alias,

  coq.indt-decl->implicits DS IndImpls KsImpls,
  if (coq.any-implicit? IndImpls)
     (coq.arguments.set-implicit (indt I) [IndImpls])
     true,
  std.forall2 KsImpls KS (i\k\
    if (coq.any-implicit? i)
       (coq.arguments.set-implicit (indc k) [i])
       true
    ),
  std.map-filter CL export? P,
  std.do! P,
].

pred short-alias i:id, i:term.
short-alias ID T :- @global! => coq.notation.add-abbreviation ID 0 T ff _.

pred indt-decl-name i:indt-decl, o:string.
indt-decl-name (parameter _ _ _ Decl) Name :-
  pi x\ indt-decl-name (Decl x) Name.
indt-decl-name (inductive Name _ _ _) Name.
indt-decl-name (record Name _ _ _) Name.

}
