/* Entry point for all derivations                                           */
/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

namespace derive {

pred if-verbose i:prop.
if-verbose P :- get-option "verbose" tt, !, P.
if-verbose _.

pred dep o:string, o:string.
dep X Y :- dep1 X Y.
dep X Y :- dep1 X Z, dep Z Y.

pred selected i:string.
selected Name :- get-option "only" Map, !,
  Map => (get-option Name _; (get-option X _, dep X Name)).
selected _.

pred chain i:list derive, o:list prop.
chain [] [].
chain [derive Name _|FS] CL :- not(selected Name), !,
  if-verbose (coq.say "Skipping derivation" Name),
  chain FS CL.
chain [derive Name F|FS] CL :- get-option "only" _, !, % request this one
  if-verbose (coq.say "Derivation" Name),
  @dropunivs! => std.time (F C) Time,
  if-verbose (coq.say "Derivation" Name "took" Time),
  C => chain FS CS,
  std.append C CS CL.
chain [derive Name F|FS] CL :- % all are selected, we can fail
  if-verbose (coq.say "Derivation" Name),
  (pi x\ stop x :- !, fail) => @dropunivs! => std.time (F C) Time, !,
  if-verbose (coq.say "Derivation" Name "took" Time),
  C => chain FS CS,
  std.append C CS CL.
chain [derive F _|FS] CL :-
  if-verbose (coq.say "Derivation" F "failed, continuing"),
  chain FS CL.

pred toposort i:list derive, o:list derive.
toposort L SL :-
  std.findall (dep1 _ _) Deps,
  topo L Deps SL.

pred std.partition i:list A, i:(A -> prop), o:list A, o:list A.
std.partition [] _ [] [].
std.partition [X|XS] P [X|R] L :- P X, !, std.partition XS P R L.
std.partition [X|XS] P R [X|L] :- std.partition XS P R L.

pred not-a-src i:list prop, i:derive.
not-a-src Deps (derive A _) :- not(std.mem! Deps (dep1 A _)).

pred tgt-is-not-in i:list derive, i:prop.
tgt-is-not-in [] _.
tgt-is-not-in [derive Tgt _|_] (dep1 _ Tgt) :- !, fail.
tgt-is-not-in [_|L] D :- tgt-is-not-in L D.

pred topo i:list derive, i:list prop, o:list derive.
topo [] _ [].
topo L Deps SL :-
  std.partition L (not-a-src Deps) LNoDeps Other,
  if (LNoDeps = []) (coq.error "derive: no topological order:" L Deps) true,
  std.filter Deps (tgt-is-not-in LNoDeps) NewDeps,
  topo Other NewDeps SOther,
  std.append LNoDeps SOther SL.

pred export? i:prop, o:prop.
export? (export M) (coq.env.export-module M).

pred main i:inductive, i:string, o:list prop.
main T Prefix CL :-
  std.findall (derivation T Prefix _) L,
  std.map L (x\r\ x = derivation _ _ r) DL,
  toposort DL SortedDL,
  chain SortedDL CL.

pred decl+main i:indt-decl.
decl+main DS :- std.do! [
  indt-decl-name DS ModName,
  if-verbose (coq.say "Starting module" ModName),
  coq.env.begin-module ModName none,
  std.assert-ok! (coq.elaborate-indt-decl-skeleton DS D) "Inductive type declaration illtyped",
  if-verbose (coq.say "Declaring inductive" D),
  coq.env.add-indt D I,
  if-verbose (coq.say "Deriving"),
  main I "" CL,
  if-verbose (coq.say "Done"),
  coq.env.end-module _,

  coq.env.indt I _ _ _ _ KS _,
  std.map KS (k\r\ r = indc k) KGRS,
  std.map KGRS coq.gref->id KNS,
  std.map KGRS (gr\r\ r = global gr) KTS,

  std.forall2 [ModName|KNS] [global (indt I)|KTS] short-alias,

  coq.indt-decl->implicits DS IndImpls KsImpls,
  if (coq.any-implicit? IndImpls)
     (coq.arguments.set-implicit (indt I) [IndImpls])
     true,
  std.forall2 KsImpls KS (i\k\
    if (coq.any-implicit? i)
       (coq.arguments.set-implicit (indc k) [i])
       true
    ),
  std.map-filter CL export? P,
  std.do! P,
].

pred short-alias i:id, i:term.
short-alias ID T :- @global! => coq.notation.add-abbreviation ID 0 T ff _.

pred indt-decl-name i:indt-decl, o:string.
indt-decl-name (parameter _ _ _ Decl) Name :-
  pi x\ indt-decl-name (Decl x) Name.
indt-decl-name (inductive Name _ _ _) Name.
indt-decl-name (record Name _ _ _) Name.

}
