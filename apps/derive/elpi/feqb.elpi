/* Entry point for all derivations                                           */
/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

namespace feqb {

kind derive type.
type derive string -> (A -> prop) -> derive.

pred if-verbose i:prop.
if-verbose P :- get-option "verbose" tt, !, P.
if-verbose _.

pred chain i:list derive, o:list prop.
chain [] [].
chain [derive Name F|FS] CL :-
  if-verbose (coq.say "Derivation" Name),
  @dropunivs! => std.time (F C) Time, !,
  if-verbose (coq.say "Derivation" Name "took" Time),
  C => chain FS CS,
  std.append C CS CL.
chain [derive F _|_] _ :- coq.error "Derivation" F "failed".

pred on_param1 i:inductive, i:(inductive -> string -> list prop -> prop), i:string, o:list prop.
on_param1 T F N C :- reali (global (indt T)) (global (indt P)), !, F P N C.

pred main i:inductive, i:string, o:list prop.
main T Prefix CL :-
  PrefixI is Prefix ^ "induction",
  SortedDL = [
    (derive "param1"         (derive.param1.main (indt T)            "is_"     )),
    (derive "param1_inhab"   (feqb.on_param1 T derive.param1.inhab.main   "_full")),
    % (derive "param1_trivial" (feqb.on_param1 T derive.param1.trivial.main "_trivial")),
    (derive "param1_functor" (feqb.on_param1 T derive.param1.functor.main "_functor")),
    (derive "induction"      (derive.induction.main T                PrefixI    )),
    (derive "tag"            (derive.tag.main T                      Prefix)),
    (derive "eqType_ast"     (derive.eqType.ast.main T               )),
    (derive "fields"         (derive.fields.main T                   Prefix)),
    (derive "eqb"            (derive.eqb.main T                      Prefix)),
    (derive "eqbcorrect"     (derive.eqbcorrect.main T               Prefix)),
  ],
  chain SortedDL CL.

pred decl+main i:indt-decl.
decl+main DS :- std.do! [
  indt-decl-name DS ModName,
  if-verbose (coq.say "Starting module" ModName),
  coq.env.begin-module ModName none,
  std.assert-ok! (coq.elaborate-indt-decl-skeleton DS D) "Inductive type declaration illtyped",
  if-verbose (coq.say "Declaring inductive" D),
  coq.env.add-indt D I,
  if-verbose (coq.say "Deriving"),
  main I "" _,
  if-verbose (coq.say "Done"),
  coq.env.end-module _,

  coq.env.indt I _ _ _ _ KS _,
  std.map KS (k\r\ r = indc k) KGRS,
  std.map KGRS coq.gref->id KNS,
  std.map KGRS (gr\r\ r = global gr) KTS,

  std.forall2 [ModName|KNS] [global (indt I)|KTS] short-alias,

  coq.indt-decl->implicits DS IndImpls KsImpls,
  if (coq.any-implicit? IndImpls)
     (coq.arguments.set-implicit (indt I) [IndImpls])
     true,
  std.forall2 KsImpls KS (i\k\
    if (coq.any-implicit? i)
       (coq.arguments.set-implicit (indc k) [i])
       true
    ),
].

pred short-alias i:id, i:term.
short-alias ID T :- @global! => coq.notation.add-abbreviation ID 0 T ff _.

pred indt-decl-name i:indt-decl, o:string.
indt-decl-name (parameter _ _ _ Decl) Name :-
  pi x\ indt-decl-name (Decl x) Name.
indt-decl-name (inductive Name _ _ _) Name.
indt-decl-name (record Name _ _ _) Name.

}
